@startuml
class CanvasRunner
interface ICanvas
class CanvasConstants
class CanvasHolder
class Canvas
class Pixel
class WidthBorder
class HeightBorder
class Status
enum StatusTypes
class Success
class Failed
class CommandParserException
class Position

interface Painter
class BoxPainter
class FillPainter
class LinePainter
class RectanglePainter

interface Command
class CreateCanvasCommand
class FillCommand
class LineCommand
class QuitCommand
class RectangleCommand
class CommandBuilder
interface CommandParser
class CreateCanvasCommandParser
class FillCommandParser
class LineCommandParser
class QuitCommandParser
class RectangleCommandParser

ICanvas <|-- CanvasHolder
ICanvas <|-- Canvas
CanvasHolder "1" o-- Canvas
Canvas "..1*" *-- Pixel
Status <|-- Success
Status <|-- Failed
Pixel *-- Position : Contains
Pixel <|-- WidthBorder
Pixel <|== HeightBorder
Status o-- StatusTypes : Contains

Painter <|-- LinePainter
Painter <|-- BoxPainter
BoxPainter <|-- RectanglePainter
Painter <|-- FillPainter

CommandParser <|-- CreateCanvasCommandParser
CommandParser <|-- FillCommandParser
CommandParser <|-- QuitCommandParser
CommandParser <|-- LineCommandParser
CommandParser <|-- RectangleCommandParser
CommandBuilder o-- CommandParser : Contains

Command <|-- CreateCanvasCommand
Command <|-- FillCommand
Command <|-- QuitCommand
Command <|-- LineCommand
Command <|-- RectangleCommand
CommandBuilder o-- Command : Contains

FillCommand o-- FillPainter : Contains
LineCommand o-- LinePainter : Contains
RectangleCommand o-- RectanglePainter : Contains

CanvasRunner o-- ICanvas : Contains
CanvasRunner o-- CommandBuilder : Contains

enum StatusTypes {
SUCCESS
FAILED
}

class CommandParserException {
    - message: String
}

class Pixel {
    - text: String
    + position: Position
    + isBlank():Boolean
    + isNotBlank():Boolean
}

class Position {
    + x: Int
    + y: Int
}

class CanvasConstants {
    + WIDTH_BORDER_CHAR = "-"
    + HEIGHT_BORDER_CHAR = "|"
    + DEFAULT_DISPLAY_CHAR  = " "
    + INVALID_TEXT_CHAR = "~"
    + LINE_DISPLAY_CHAR = "*"
}

interface ICanvas {
    + printScreen()
    + isPositionAvailable(pos: Position): Boolean
    + isPositionWritable(pos: Position): Boolean
    + getPixelValueAt(pos: Position): String
    + setPixelValueAt() : Boolean
    + setPixelValueBetween() : List<Position>
    + writableChildrenOf(pos: Position): List<Position>
}
class Canvas {
    + pixels: Array<Array<Pixel>>
    + printScreen()
    + isPositionAvailable(pos: Position): Boolean
    + isPositionWritable(pos: Position): Boolean
    + getPixelValueAt(pos: Position): String
    + setPixelValueAt() : Boolean
    + setPixelValueBetween() : List<Position>
    + writableChildrenOf(pos: Position): List<Position>
}

class CanvasHolder {
    - canvas: Canvas
    + printScreen()
    + isPositionAvailable(pos: Position): Boolean
    + isPositionWritable(pos: Position): Boolean
    + getPixelValueAt(pos: Position): String
    + setPixelValueAt(): Boolean
    + setPixelValueBetween(): List<Position>
    + writableChildrenOf(pos: Position): List<Position>
}

class Status {
    + status: StatusTypes
}

interface Painter {
    + validate(canvas: ICanvas): Status
    + paint(canvas: ICanvas) : Status
}

class BoxPainter {
    - start: Position
    - end: Position
    + validate(canvas: ICanvas): Status
    + paint(canvas: ICanvas): Status
}

class FillPainter {
    - start:Position
    - colour: String
    + validate(canvas: ICanvas): Status
    + paint(canvas: ICanvas): Status
    - fillByBreadthFirstSearch(canvas: ICanvas) : Success
}

class LinePainter {
    - start: Position
    - end: Position
    + validate(canvas: ICanvas) : Status
    + paint(canvas: ICanvas): Status
}

class RectanglePainter {
    + validate(canvas: ICanvas): Status
}

interface Command {
    + execute(canvas: ICanvas) : Status
}

class CreateCanvasCommand {
     ~ width: Int
     ~ height: Int
     + execute(canvas: ICanvas): Status
}

class FillCommand {
    ~ startWidth: Int
    ~ startHeight: Int
    ~ colour:String
    + execute(canvas: ICanvas): Status
}

class LineCommand {
    ~ startWidth: Int
    ~ startHeight: Int
    ~ endWidth: Int
    ~ endHeight: Int
    + execute(canvas: ICanvas): Status
}

class QuitCommand {
    + execute(canvas: ICanvas): Status
}

class RectangleCommand {
    ~ startWidth: Int
    ~ startHeight: Int
    ~ endWidth: Int
    ~ endHeight: Int
    + execute(canvas: ICanvas): Status
}

interface CommandParser {
    + isMatched(cmd:String): Boolean
    + parseCommand(cmd: String): Command
}

class CreateCanvasCommandParser {
    + isMatched(cmd: String): Boolean
    + parseCommand(cmd: String): Command
}

class FillCommandParser {
    + isMatched(cmd: String): Boolean
    + parseCommand(cmd: String): Command
}

class LineCommandParser {
    + isMatched(cmd: String): Boolean
    + parseCommand(cmd: String): Command
}

class QuitCommandParser {
    + isMatched(cmd: String): Boolean
    + parseCommand(cmd: String): Command
}

class RectangleCommandParser {
    + isMatched(cmd: String): Boolean
    + parseCommand(cmd: String): Command
}

class CanvasRunner {
    + main(args: Array<String>)
    - canvas: ICanvas
    - builder:CommandBuilder
    - readLine(): String
    ~ executeCommand(command: String)
    - executeConsoleCommands()
    + start()
}

class CommandBuilder {
    - command: String
    + setStringCommand(string: String):CommandBuilder
    + build():Command
}
@enduml